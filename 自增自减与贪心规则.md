### 自增自减与贪心规则

#### 1. 前缀式 与 后缀式的真正区别

在Java中，运算是从左往右计算的，并且按照运算符的优先级，逐一计算出表达式的值，并用这个值参与下一个表达式的运算，如：`1+2+3`，其实是先计算出`1+2`表达式的值为3，再参与下一个表达式的运算`(1+2)+3`，即`3+3`。再如判断`if(a+2==3)`。如此类推。

  `a++`是一个表达式 ，那么`a++`就会有一个表达式的计算结果，这个计算结果就是a的旧值（加1前的值）。相对的，`++a`表达式的计算结果a加1后的值。所以，自增的前缀形式与后缀形式的本质区别是：表达式的值（运算结果） 是加1前的变量的值还是加1后的变量的值（自减也是如此）。并不是先加1 与 后加1的区别，或者说，前后缀形式都是先加1（减1）的，才得到表达式的值，再参与下一步运算。因为这是一个表达式，必须先计算完表达式的运算，最后才会得到表达式的值

```
int a = 5;
a = a++;
1、计算a自加1，即 a=a+1
2、计算表达式的值，因为这是后缀形式，所以a++表达式的值就是加1前a的值(值为5)；
3、将表达式的值赋值给a，即a=5。
```

#### 2. 自增自减是包含两个两个操作，不是线程安全的

自增、自减运算符本质上不是一个计算操作，而是两个计算操作。以`a++`为例，这个运算将会编译器解析成：`a=a+1`，即包含两个单目运算符（+、=）,一个单目运算符的计算操作可以看作是一个原子性操作。`a++`的步骤可以描述成 ：
  1、先取a加1，将结果存储在临时空间；
  2、将结果赋给a。所以，自增自减运算符包含两个操作：一个加1（减1）的操作和一个赋值的操作

  在多线程的情况下，自增自减不是原子性操作，也就是说不是线程安全的运算。**因此，在多线程下，如果你要对共享变量实现自增自减操作，就要加锁，或者使用JDK提供的原子操作类（如`AtomincInteger`，`AtomicLong`等）提供的原子性自增自减方。

```
public class MyTest {
    static int a = 0;
    static int b = 0;
    //原子性操作类
    static AtomicInteger atomicInt = new AtomicInteger(0);
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10; i++) {//创建10个线程
            Thread t = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < 1000; j++) {//计算1000次
                        a = a + 1;
                        b++;
                        atomicInt.incrementAndGet();//自增的原子性方法
                    }
                }
            };
            t.start();
        }
        // 判断当前的活动线程是不是只有main线程，以确保10个计算线程执行完成。
        while (Thread.activeCount() > 1) {
            Thread.sleep(1000);
        }
        System.out.println("a=a+1在多线程下的结果是：" + a);
        System.out.println("b++在多线程下的结果是：" + b);
        System.out.println("原子操作类AtomicInteger在多线程下的结果是：" + atomicInt.get());
    }
}

a=a+1在多线程下的结果是：8883
b++在多线程下的结果是：8974
原子操作类AtomicInteger在多线程下的结果是：10000
```

从运行的结果可以看出，`a=a+1、b++`不是线程安全的，没有计算出正确的结果10000。也就是说这两个表达式都不是原子性操作。事实上，它们都包含了两个计算操作。

#### a+++b 表达式引起的思考

```
int a = 5;
    int b = 5;
    int c=a+++b;
    System.out.println("a的值是: "+a);
    System.out.println("b的值是: "+b);
a的值是: 6
b的值是: 5
```

- Java中的运算是从左往右进行的；
- java编译器有一种规则——贪心规则。也就是说，编译器会尽可能多地结合有效的符号。

a--b会被编译器解析成a-- b

#### 编译器为什么要采用贪心规则呢？

```
  String s = "\17";
    System.out.println("\\17 转义字符的值是："+s+"  长度是："+s.length());
    s = "\171";
    System.out.println("\\171 转义字符的值是："+s+"  长度是："+s.length());
    s = "\1717";
    System.out.println("\\1717 转义字符的值是："+s+"  长度是："+s.length());
    s = "\17178";
    System.out.println("\\17178 转义字符的值是："+s+"  长度是："+s.length());
\17 转义字符的值是：   长度是：1
\171 转义字符的值是：y   长度是：1
\1717 转义字符的值是：y7   长度是：2
\17178 转义字符的值是：y78   长度是：3
```

八进制的转义字符的取值范围是 \0~\377。所以解析 ”\171“ 字符串时，编译器尽可能多地结合字符成一个转移字符，”\171“ 还在取值范围内，所以就是一个字符。但 ”\1718” 字符串，最多结合前4个字符成一个有效的转义字符 “\171”，而“\1717” 已经超出取值范围，不是有效字符，所以最后解析成 “\171” + "7" 的结果。“17178” 也是如此。